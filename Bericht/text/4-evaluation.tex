\section{Evaluation}
\label{chap:evaluation}
Am Ende unserer Arbeit wurde uns ein Framework des SAFEST-Projekts zur Verfügung gestellt, dass die Möglichkeit bietet, verschiedene vorimplementierte Algorithmen mit einander zu vergleichen.\\
Nachdem wir unseren Algorithmus in das Framework integriert hatten, haben die folgenden Vergleiche mit einer vorimplementierten, Histogramm-basierten Lösung angestellt:
\begin{itemize}
	\item[a)] die vorimplementierte Lösung, die mit Histogrammen arbeitet
	\item[b)] unsere HMM-basierte Lösung mit generischen Werten für Initialwerte, Emission und Transition ohne Lernen
	\item[c)] unsere HMM-basierte Lösung mit generischen Werten für Initialwerte, Emission und Transition mit Lernen
\end{itemize}
Weitere Vergleiche haben wir nicht angestellt, da das Histogramm-basierte Verfahren den anderen Verfahren entweder überlegen ist (OpenCV MOG und OpenCV MOG2) oder aber das Verfahren den Hintergrund hart auf bestimmte Videos kodiert (MEAN) und sehr unflexibel ist, sobald der Hintergrund nicht mehr uniform ist.\\
Das Ergebnis haben wir jeweils visualisiert, indem wir für jeden zu evaluierenden Algorithmus die Abweichung vom eigentlich erwarteten Wert visualisiert haben.
Ein optimal funktionierender Algorithmus würde also als Bild im Diagramm ohne Abweichungen die Nulllinie verdecken.\\
Die erwarteten Werte für diesen Vergleich sind uns seitens des SAFEST Projekts zur Verfüngung gestellt worden.
\subsection{Vergleich mit Histogramm-basierter Implementierung: Innenhof}
\label{sec:eval_innenhof}
\begin{figure}
	\centering
\includegraphics[width=1\textwidth]{bilder/innenhof_910-1000_histo_vs_hmm_prelearned.pdf}
\caption{Innenhof: Histogramm vs. trainiertes HMM}
	\label{fig:Innenhof}
\end{figure}
In Grafik \ref{fig:Innenhof} sieht man, dass der Histogramm-basierte Algorithmus für dieses Video bessere Ergebnisse liefert, als der HMM-basierte Algorithmus.\\

\subsection{Vergleich mit Histogramm-basierter Implementierung: Tegel}
\label{sec:eval:tegel}
\begin{figure}
	\centering
\includegraphics[width=1\textwidth]{bilder/tegel_7-55_histo_vs_prelearned_hmm.pdf}
	\caption{Tegel: Histogramm vs. trainiertes HMM}
	\label{fig:tegel}
\end{figure}

Wie man Abbildung \ref{fig:tegel} entnehmen kann, sind die Ergebnisse beider Algorithen vom Verlauf her sehr ähnlich.
Allerdings hat der HMM-basierte Algorithmus gegenüber dem Histogram-basierten kleine Vorteile.
Zwischen 30 und 50 Sekunden hat er eine deutlich geringere Abweichung vom korrekten Wert.
Dasselbe gilt für den Bereich zwischen ca. 65 und 80 Sekunden.\\
%Insgesamt kann man aber sagen, dass am überraschensten ist, wie ähnlich der Verlauf der beiden Graphen ist. Zum Teil ist dies sicher darauf zurückzuführen, dass der Clustering-Algorithmus in beiden Fällen nicht richtig gut funktioniert.

\subsection{Vergleich mit Histogramm-basierter Implementierung: Eingang}
\label{sec:eval_eingang}
\begin{figure}
	\centering
\includegraphics[width=1\textwidth]{bilder/eingang2_histo_vs_hmm_prelearned.pdf}
\caption{Eingang: Histogramm vs. trainiertes HMM (gesamt)}
	\label{fig:Eingang-gesamt}
\end{figure}
\begin{figure}
	\centering
	\includegraphics[width=1\textwidth]{bilder/safest_plot_histo_vs_prelearned_652-end.pdf}
	\caption{Eingang: Histogramm vs. trainiertes HMM, Auschnitt Frame 651-Ende}
	\label{fig:Eingang-teil}
\end{figure}
In der Grafik \ref{fig:Eingang-gesamt} sieht man, dass beide Algorithmen hier nicht wirklich gut funktioieren.
Dies ist aufgrund der Eigenschaften des Videos zu erwarten: der Hintergrund ist sehr hell und die Kalibrierung der Kamera fällt hier auch optisch sehr stark auf.\\
Während in der ersten Hälfte des Videos der Histogramm-basierte Algorithmus noch Vorteile hat (relativ viele korrekte Anzeigen, der HMM-basierte Algorithmus erkennt meist eine Person zu viel). ist der HMM-basierte Algorithmus in der zweiten Hälfte des Videos (ab etwa Frame 450) deutlich besser.
in Grafik \ref{fig:Eingang-teil} sieht, gibt es wesentlich weniger Ausreißer und das Ergebnis ist insgesamt auch viel dichter am korrekten Wert.\\
%Wie auch im Falle der Tegelvideos liegt der Fehler aber auch hier daran, dass der Clustering Algorithmus häufig einen Menschen in mehrere Cluster teilt, weil er nicht gut genug an das Video angepasst ist. Wenn man den Clustering-Algorithmus entsprechend anpassen würde, so dass eine Mensch nicht mehr in 2-4 Cluster geteilt wird, würde der HMM-basierte Algorithmus in der zweiten Hälfte des Bildes vermutlich sehr dicht am korrekten Wert liegen.

\subsection{Diskussion}
\label{sec:diskuss}
Aus den vorangegangenen Grafiken kann man erst einmal ablesen, dass beide Algorithmen grundsätzlich dazu geeignet sind, Vorder- von Hintergrund zu trennen.
Da die Graphen je einmal für den Histogramm-basierten und den HMM-basierten Algorithmus darstellen, fallen einige Details auf, die erklärt werden müssen.
Außer im Falle von Grafik \ref{fig:Innenhof} (Innenhof) sind die Verläufe der beiden Graphen sehr ähnlich.
Dies legt nahe, dass der dargestellte Fehler nicht nur an den geprüften Algorithmen liegt, sondern jedenfall teilweise durch das Clustering erzeugt wird.
Dieser Umstand deckt sich mit der Beobachtung, dass bei den Tegel- und Eingang-Videos einzelne Personen in zwei oder mehr Cluster geteilt werden.\\
Wie aus Grafik \ref{fig:Eingang-gesamt} und \ref{fig:Eingang-teil} (Eingang) hervorgeht, hat der von uns entwickelte HMM-basierte Algorithmus besonders bei schwieriger zu verarbeitendem Videomaterial Vorteile bei der Erkennung.\\
Allerdings haben wir nur \glqq Offline-Learning\grqq genutzt, da die uns zur Verfügung gestellten Sequenzen für \glqq Online-Learning\grqq zu kurz waren.
Wenn wir versucht haben, online zu lernen, führte dies immer zu schlechteren Ergebnissen aufgrund von Geisterbildern.\\
Den größten Vorteil hat der Histogramm-basierte Algorithmus bei der Performance: whärend hier mit 22-25 fps eine flüssige Videodarstellung noch möglich war, lief der HMM-basierte Algorithmus nur mit ca. 10-12 fps. Hier wäre also noch Potential zur Verbesserung.

%TODO:
 %bezug auf anforderungen nehmen, punkte erfüllt?
 %hmm topologie?
 %andere libs?
 %dynamische histrogramm/cluster grenzen für dc wert in zukunft?
 %viterbi/forawrd gibt zustand, man kann entweder gewichtestes würfeln oder aber deterministisch die wahrschienlichste beobachtung nehmen, was ist besser? -> test?
 %performance gewinn durch threading zusätzlich


\subsection{CvHMM}
\label{sec:CvHMM}
Leider hat sich im Laufe des Projekts gezeigt, dass CvHMM leider sehr ineffizient auf einzelne Daten zugreift. Dies konnten wir mit Hilfe von Callgrind (Teil von Valgrind) nachweisen.
Hieraus ergeben sich auch die in \ref{sec:diskuss} angesprochenen Performance Probleme.\\ 
Ein weiterer großer Nachteil von CvHMM ist, dass nur der Baum-Welch-, der Viterbi- und der Decode-Algorithmus angeboten werden.
 Gerade hier ist wiederum ein Manko zu sehen, da wir später den Forward-Algorithmus gebraucht hätten und nun stattdessen den Viterbi-Algorithmus verwenden müssen, der jedoch ineffizienter als der Forward-Algorithmus ist.\\
Zusammenfassend lässt sich zur Wahl der HMM Bibliothek sagen, dass es wohl das Ergebnis des Projekts erheblich hätte verbessern können, wenn unsere Wahl auf eine andere Bibliothek gefallen wäre.\\
